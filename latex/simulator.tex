\chapter{Simulator}
\label{chapter:simulator}

Testing and evaluating a peer-to-peer protocol with thousands of nodes in a real environment is very difficult, expensive and time consuming, especially if the goal is to evaluate the effects of large-scale network attacks.
For this reason, we decided to implement a simulator to measure the performances of the Bitcoin protocol under the different situations, at rest and under attack.
This allowed us to simulate up to \num{8000} Bitcoin nodes on a single general-purpose computer in a short time and evaluate the behavior of the protocol under different attacks scenarios.

\medskip
This chapter describes the implementation of the simulator.
It covers the main concepts of discrete event simulation, the basics of PeerSim, the design and of the simulator source code, the simplifications with respect to the complete Bitcoin protocol, and the metrics used to measure and evaluate the overall performances.


\section{Simulation}
According to Robert E. Shannon, \textit{simulation} is ``the process of designing a model of a real system and conducting experiments with this model for the purpose of understanding the behavior of the system and / or evaluating various strategies for the operation of the system'' \cite{simulation_shannon_1998}.
By \textit{model}, help means an abstract representation of an entity of group of objects, and by \textit{system} a collection of elements that interact with each other to accomplish some objective.
According to Shannon, simulation has a number of advantages \cite{simulation_shannon_1998}:
\begin{itemize}
	\item it is often easier to understand than analytical or mathematical models;
	\item it is usually more credible than models, since it requires less simplifying assumptions and is thus able to represent the system more accurately;
	\item it allows to test new designs, systems or protocols before implementing them;
	\item it allows to test hypothesis and measure their effects on the systems;
	\item it allows to better understand how the modeled system works and which variables are the most important with respect to the performances;
	\item it allows to changes the initial situation and test the system in different settings.
\end{itemize}

\medskip
Simulation is used in many contexts, for example safety engineering, economics, physics and even video games \cite{wikipedia_simulation}.
There are many different approaches to simulations, each one adapted to a specific purpose.
We focus on discrete event simulation, used by our simulator.


\section{Discrete event simulation}
A discrete event simulation models the system behavior as a discrete sequence of events in time.
An event can represent anything, for example the arrival of a message to a node in the system or a network timeout.
Each event occurs at a particular instant of time and possibly causes some change in the state of the system.
No event occurs between two consecutive events, so the simulation can simply jump from one event to the next.
The results of the simulation can be evaluated with some metrics:
the metrics can be computed either online during the simulation run, or computed offline from the simulation logs.

\medskip
\begin{algorithm}
	\caption{Discrete Event Simulator}
	\label{alg:des}
	\begin{algorithmic}
		\State $state \leftarrow \Call{initializeState()}{}$
		\State $events \leftarrow \Call{initializeEvents()}{}$
		\State $queue \leftarrow \Call{PriorityQueue()}{}$
		\State $queue.\Call{add}{events}$

		% ------------------------------------------------------
		% TODO!!!
		% ------------------------------------------------------

		\State $state \leftarrow \Call{initializeState()}{}$
		\State $events \leftarrow \Call{initializeEvents()}{}$
		\State $queue \leftarrow \Call{PriorityQueue()}{}$
		\State $queue.\Call{add}{events}$
	\end{algorithmic}
\end{algorithm}
\smallskip

\cref{alg:des} illustrate the working of a discrete event simulation engine.
The simulation has some starting state that represents the initial condition of the system.
All events are stored in a priority queue sorted by event time.
The queue is initialized with some events.
Events in the queue are processed one at a time:
the first event is removed from the queue and processed by the simulator.
An event can cause other events to occur in the future and change the current state if the system.
Discrete event simulators take advantage of pseudorandom number generators to emulate random variables of the system \cite{wikipedia_des}:
whenever an event is influenced by some random factor external to the system (e.g. latency of a TCP connection over the Internet), the simulator extracts a random variable from some distribution using the random number generators.
The simulation stops when a certain condition is reached (for example, a target simulation time is reached), or when the queue of events is empty.

\section{PeerSim}
PeerSim \cite{peersim_2009} is an open source peer-to-peer systems simulator engine developed at the University of Bologna and the University of Trento.
It is written in Java and aim is to help the research and evaluation of large peer-to-peer.
It has been developed with high scalability in mind, in order to support simulations with up to \num{1} million nodes.
It is released under the GPL open source license and is available for download on SourceForce \footnote{\url{http://peersim.sourceforge.net/}}.

\smallskip
PeerSim is composed of two simulation engines, a simplified (cycle-based) one and an event-driven one.
The cycle-based engine uses some simplifying assumptions to achieve better performances and scalability, such as ignoring the details of the transport layer in the communication protocol stack;
it has been tested up to \num{1} million nodes \cite{peersim_intro_2018}.
The event-based engine is less efficient but more realistic and allows to easily simulate the entire network stack;
it has been used for simulation of up to \num{250000} nodes \cite{peersim_intro_2018}.
Both engines support many simple and extendable, with are plugged together through a flexible configuration mechanism.
Since our simulator is event driven, this chapter focuses on the event-based engine only.
